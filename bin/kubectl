#!/bin/bash

# Drop-in replacement for kubectl with automatic namespace discovery and pattern matching.
# Usage: kubectl <command> [kind] [pattern_or_flags]
# Commands: search, describe, get, logs, exec, delete, connect

set -e

# Generic function to get original command path (bypassing wrapper scripts)
get_original_command() {
    local cmd="$1"
    if [ -z "$cmd" ]; then
        echo "Error: command name required" >&2
        return 1
    fi
    
    local original_path="$PATH"
    local script_dir=$(dirname "$0")
    PATH=$(echo "$PATH" | sed "s|:$script_dir||g" | sed "s|^$script_dir:||g")
    local cmd_path=$(command -v "$cmd")
    PATH="$original_path"
    echo "$cmd_path"
}

# Get the original kubectl command
KUBECTL_CMD=$(get_original_command "kubectl")

# Help function
show_help() {
    cat << EOF
Kubernetes Object Search and Operations Tool

Usage: kubectl <command> [kind] [pattern_or_flags]

Commands:
    search <kind> <pattern>     - Search for objects of specified kind matching the pattern
    describe <kind> <pattern>   - Describe objects of specified kind matching the pattern
    get <kind> <pattern>        - Get YAML for objects of specified kind matching the pattern
    logs <pattern>              - Show logs for pods matching the pattern (kind is always 'pods')
    exec [flags] <pod> [--] <command> - Execute command in pods (supports kubectl exec flags like -it)
    delete <kind> <pattern>     - Delete objects of specified kind matching the pattern
    connect <pattern> [shell]   - Connect to pod with shell (default: /bin/bash, options: sh, bash)

Options:
    -v, --verbose              - Enable verbose mode (shows commands being executed)
    -h, --help                 - Show this help

Examples:
    kubectl search pods data-plane-agent
    kubectl describe pods keycloak-0
    kubectl get deployments my-app
    kubectl logs data-plane-agent
    kubectl exec -it keycloak-0 -- /bin/bash
    kubectl exec keycloak-0 -- ls -la
    kubectl connect keycloak-0
    kubectl connect keycloak-0 sh
    kubectl delete pods old-pod
    kubectl -v describe pods my-pod
    kubectl get pods -A

EOF
}

# Private function to find namespace and name of objects matching pattern
find_namespace() {
    local kind="$1"
    local pattern="$2"
    
    local result=$($KUBECTL_CMD get "$kind" --all-namespaces | grep -i "$pattern" 2>/dev/null | head -n1 | awk '{print $1 " " $2}')
    
    if [ -n "$result" ]; then
        echo "$result"
    fi
}

# Search function - finds objects matching pattern
search() {
    local kind="$1"
    local pattern="$2"
    shift 2  # Remove kind and pattern, leaving additional args in "$@"
    
    # Find namespace and name using find_namespace
    local result=$(find_namespace "$kind" "$pattern")
    
    if [ -n "$result" ]; then
        local namespace=$(echo "$result" | awk '{print $1}')
        local name=$(echo "$result" | awk '{print $2}')
        echo "$namespace $name"
    fi
}

# Generic function to run kubectl commands with namespace discovery
kubectl_wrapper_command() {
    local kubectl_cmd="$1"
    local kind="$2"
    local pattern="$3"
    shift 3  # Remove kubectl_cmd, kind, and pattern, leaving additional args in "$@"
    
    # Find namespace and name using find_namespace
    local result=$(find_namespace "$kind" "$pattern")
    
    if [ -n "$result" ]; then
        local namespace=$(echo "$result" | awk '{print $1}')
        local name=$(echo "$result" | awk '{print $2}')
        $KUBECTL_CMD "$kubectl_cmd" "$kind" "$name" -n "$namespace" "$@"
    fi
}

# Get YAML function
get_yaml() {
    local kind="$1"
    local pattern="$2"
    shift 2  # Remove kind and pattern, leaving additional args in "$@"
    kubectl_wrapper_command "get" "$kind" "$pattern" -o yaml "$@"
}

# Logs function
logs() {
    local kind="$1"
    local pattern="$2"
    shift 2  # Remove kind and pattern, leaving additional args in "$@"
    
    # Find objects (only works for pods)
    if [ "$kind" != "pods" ]; then
        echo "Error: logs command only works with pods" >&2
        return 1
    fi
    
    # Find namespace and name using find_namespace
    local result=$(find_namespace "$kind" "$pattern")
    
    if [ -n "$result" ]; then
        local namespace=$(echo "$result" | awk '{print $1}')
        local name=$(echo "$result" | awk '{print $2}')
        $KUBECTL_CMD logs "$name" -n "$namespace" "$@"
    fi
}

# Exec function
exec() {
    # exec always works with pods, no need for kind parameter
    
    # Parse arguments to find pod name and flags
    local flags=()
    local pod_name=""
    local command_args=()
    local found_pod=false
    
    # Parse all arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --)
                # Everything after -- goes to command
                shift
                command_args+=("$@")
                break
                ;;
            -*)
                # This is a flag, keep it
                flags+=("$1")
                shift
                ;;
            *)
                # This could be the pod name or part of command
                if [[ "$found_pod" == "false" ]]; then
                    pod_name="$1"
                    found_pod=true
                else
                    # This is part of the command
                    command_args+=("$1")
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$pod_name" ]]; then
        echo "Error: No pod name provided" >&2
        return 1
    fi
    
    # Find namespace and name using find_namespace (always use pods)
    local result=$(find_namespace "pods" "$pod_name")
    
    if [ -n "$result" ]; then
        local namespace=$(echo "$result" | awk '{print $1}')
        local name=$(echo "$result" | awk '{print $2}')
        
        $KUBECTL_CMD exec "${flags[@]}" "$name" -n "$namespace" -- "${command_args[@]}"
    else
        echo "Error: Pod '$pod_name' not found" >&2
        return 1
    fi
}

# Connect function - shortcut for exec with shell
connect() {
    local pattern="$1"
    local shell="$2"
    
    # Default to bash if no shell specified
    if [ -z "$shell" ]; then
        shell="/bin/bash"
    elif [ "$shell" = "sh" ]; then
        shell="/bin/sh"
    elif [ "$shell" = "bash" ]; then
        shell="/bin/bash"
    fi
    
    # Use exec function with -it flags and the specified shell
    exec "-it" "$pattern" "--" "$shell"
}

# Main argument parsing
main() {
    local command=""
    local kind=""
    local pattern=""
    local skip_direct_execution=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            search|describe|get|delete)
                command="$1"
                kind="$2"
                pattern="$3"
                # Shift only the arguments that exist
                if [ $# -ge 3 ]; then
                    shift 3
                elif [ $# -ge 2 ]; then
                    shift 2
                else
                    shift
                fi
                # Remaining args are passed to the command function
                break
                ;;
            logs)
                command="$1"
                kind="pods"
                pattern="$2"
                shift 2
                # Remaining args are passed to the command function
                break
                ;;
            exec)
                command="$1"
                kind="pods"
                skip_direct_execution=true
                shift 1  # Remove command, keep all remaining args for exec function
                # Remaining args are passed to the command function
                break
                ;;
            connect)
                command="$1"
                kind="pods"
                skip_direct_execution=true
                shift 1  # Remove command, keep all remaining args for connect function
                # Remaining args are passed to the command function
                break
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Validate command, kind, and pattern
    if [ -z "$command" ]; then
        echo "Error: Command is required"
        show_help
        exit 1
    fi
    
    if [ -z "$kind" ]; then
        echo "Error: Kind is required"
        show_help
        exit 1
    fi

    # Handle commands like kubectl get pods -A
    if [[ "$skip_direct_execution" == "false" ]] && ([ -z "$pattern" ] || [[ "$pattern" =~ ^- ]]); then
        # If pattern is a flag, add it back to the arguments
        if [[ "$pattern" =~ ^- ]]; then
            set -- "$pattern" "$@"
        fi
        $KUBECTL_CMD "$command" "$kind" "$@"
        exit 0
    fi
    
    # Execute command
    case $command in
        search)
            search "$kind" "$pattern" "$@"
            ;;
        describe)
            kubectl_wrapper_command "describe" "$kind" "$pattern" "$@"
            ;;
        get)
            get_yaml "$kind" "$pattern" "$@"
            ;;
        delete)
            kubectl_wrapper_command "delete" "$kind" "$pattern" "$@"
            ;;
        logs)
            logs "$kind" "$pattern" "$@"
            ;;
        exec)
            exec "$@"
            ;;
        connect)
            connect "$1" "$2"
            ;;
        *)
            echo "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
