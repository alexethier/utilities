#!/bin/bash

# Tired of always having to specify the namespace (-n) flag for every command, worry no more!
# This is a drop-in replacement for kubectl with automatic namespace discovery and pattern matching.
# When using kubectl in dev, specifying the namespace is often unnecessary because the resource name is unique within the cluster
# This script searches for and finds the namespace for an entity if no namespace is supplied.
# Usage: kubectl <command> [kind] [pattern_or_flags]
# Commands: search, describe, get, logs, exec, delete, connect

set -e

# Generic function to get original command path (bypassing wrapper scripts)
get_original_command() {
    local cmd="$1"
    if [ -z "$cmd" ]; then
        echo "Error: command name required" >&2
        return 1
    fi
    
    local original_path="$PATH"
    local script_dir=$(dirname "$0")
    PATH=$(echo "$PATH" | sed "s|:$script_dir||g" | sed "s|^$script_dir:||g")
    local cmd_path=$(command -v "$cmd")
    PATH="$original_path"
    echo "$cmd_path"
}

# Get the original kubectl command
KUBECTL_CMD=$(get_original_command "kubectl")

# Help function
show_help() {
    cat << EOF
Drop-in replacement for kubectl with automatic namespace discovery and pattern matching.
Regular kubectl commands work as-is. If a namespace flag (-n/--namespace) is provided, 
commands pass through directly to kubectl. Otherwise, namespace is automatically discovered.

Enhanced Commands:
    search <kind> <pattern>              - Search for objects matching the pattern
    describe <kind> <pattern>            - Describe objects matching the pattern
    get <kind> <pattern>                 - Get YAML for objects matching the pattern
    logs <pattern>                       - Show logs for pods matching the pattern
    exec [flags] <pod> [--] <command>    - Execute command in pod (supports kubectl exec flags)
    delete <kind> <pattern>               - Delete objects matching the pattern
    connect <pattern> [shell]            - Connect to pod with shell (default: /bin/bash)

Options:
    -v, --verbose                        - Enable verbose mode
    -h, --help                           - Show this help

Examples:
    kubectl search pods data-plane-agent
    kubectl describe pods keycloak-0
    kubectl get deployments my-app
    kubectl logs data-plane-agent
    kubectl exec -it keycloak-0 -- /bin/bash
    kubectl connect keycloak-0
    kubectl delete pods old-pod
    kubectl get pods -A                  - Passes through to kubectl (flag as pattern)
    kubectl get pods keycloak-0 -n keycloak  - Passes through to kubectl (namespace flag provided)

EOF
}

# Check if namespace flag is present in arguments
has_namespace_flag() {
    for arg in "$@"; do
        if [[ "$arg" == "-n" ]] || [[ "$arg" == "--namespace" ]]; then
            return 0  # true
        fi
    done
    return 1  # false
}

# Private function to find namespace and name of objects matching pattern
find_namespace() {
    local kind="$1"
    local pattern="$2"
    
    # Get all matching results
    local all_matches=$($KUBECTL_CMD get "$kind" --all-namespaces | grep -i "$pattern" 2>/dev/null | awk '{print $1 " " $2}')
    
    # Count matches
    local match_count=$(echo "$all_matches" | grep -v '^$' | wc -l | tr -d ' ')
    
    if [ "$match_count" -eq 1 ]; then
        # Exactly one match - return it
        echo "$all_matches"
    else
        # Error case: no matches or multiple matches
        if [ "$match_count" -eq 0 ]; then
            echo "Error: No $kind found matching pattern '$pattern'" >&2
        else
            echo "Error: Multiple $kind found matching pattern '$pattern':" >&2
            echo "$all_matches" | head -n 3 | sed 's/^/  /' >&2
            if [ "$match_count" -gt 3 ]; then
                echo "  ..." >&2
            fi
        fi
        return 1
    fi
}

# Search function - finds objects matching pattern
search() {
    local kind="$1"
    local pattern="$2"
    shift 2
    
    local namespace_record=$(find_namespace "$kind" "$pattern")
    
    if [ -z "$namespace_record" ]; then
        return 1
    fi
    
    local namespace=$(echo "$namespace_record" | awk '{print $1}')
    local name=$(echo "$namespace_record" | awk '{print $2}')
    echo "$namespace $name"
}

# Generic function to run kubectl commands with namespace discovery
kubectl_wrapper_command() {
    local kubectl_cmd="$1"
    local kind="$2"
    local pattern="$3"
    shift 3
    
    local namespace_record=$(find_namespace "$kind" "$pattern")
    
    if [ -z "$namespace_record" ]; then
        return 1
    fi
    
    local namespace=$(echo "$namespace_record" | awk '{print $1}')
    local name=$(echo "$namespace_record" | awk '{print $2}')
    $KUBECTL_CMD "$kubectl_cmd" "$kind" "$name" -n "$namespace" "$@"
}

# Get YAML function
get_yaml() {
    local kind="$1"
    local pattern="$2"
    shift 2
    kubectl_wrapper_command "get" "$kind" "$pattern" -o yaml "$@"
}

# Logs function
logs() {
    local kind="$1"
    local pattern="$2"
    shift 2
    
    if [ "$kind" != "pods" ]; then
        echo "Error: logs command only works with pods" >&2
        return 1
    fi
    
    local namespace_record=$(find_namespace "$kind" "$pattern")
    
    if [ -z "$namespace_record" ]; then
        return 1
    fi
    
    local namespace=$(echo "$namespace_record" | awk '{print $1}')
    local name=$(echo "$namespace_record" | awk '{print $2}')
    $KUBECTL_CMD logs "$name" -n "$namespace" "$@"
}

# Exec function
exec() {
    # exec always works with pods, no need for kind parameter
    
    # Parse arguments to extract:
    # - Flags: kubectl exec flags (e.g., -it, -c) that should be passed through
    # - Pod name: first non-flag argument before -- separator
    # - Command separator: -- marks the start of the command to execute
    # - Command args: all arguments after -- that form the command
    # Then find namespace automatically using the pod name
    local flags=()
    local pod_name=""
    local command_args=()
    local found_pod=false
    local found_separator=false
    while [[ $# -gt 0 ]]; do
        case $1 in
            --)
                # Everything after -- goes to command
                found_separator=true
                shift
                command_args+=("$@")
                break
                ;;
            -*)
                # Any flag (e.g., -it, -c) - preserve it to pass to kubectl exec
                flags+=("$1")
                shift
                ;;
            *)
                # Non-flag argument: could be pod name (first one before --) or command arg (after -- or after pod)
                if [[ "$found_pod" == "false" ]] && [[ "$found_separator" == "false" ]]; then
                    # First non-flag argument before -- is the pod name/pattern
                    pod_name="$1"
                    found_pod=true
                else
                    # This is part of the command to execute in the pod
                    command_args+=("$1")
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$pod_name" ]]; then
        echo "Error: No pod name provided" >&2
        return 1
    fi
    
    local namespace_record=$(find_namespace "pods" "$pod_name")
    
    if [ -z "$namespace_record" ]; then
        return 1
    fi
    
    local namespace=$(echo "$namespace_record" | awk '{print $1}')
    local name=$(echo "$namespace_record" | awk '{print $2}')
    
    # kubectl exec syntax: kubectl exec [flags] POD -n NAMESPACE -- COMMAND [args...]
    $KUBECTL_CMD exec "${flags[@]}" "$name" -n "$namespace" -- "${command_args[@]}"
}

# Connect function - shortcut for exec with shell
connect() {
    local pattern="$1"
    local shell="$2"
    
    # Default to bash if no shell specified
    if [ -z "$shell" ]; then
        shell="/bin/bash"
    elif [ "$shell" = "sh" ]; then
        shell="/bin/sh"
    elif [ "$shell" = "bash" ]; then
        shell="/bin/bash"
    fi
    
    # Use exec function with -it flags and the specified shell
    exec "-it" "$pattern" "--" "$shell"
}

# Main argument parsing
main() {
    # If namespace is provided anywhere in arguments, pass through directly to original kubectl
    if has_namespace_flag "$@"; then
        $KUBECTL_CMD "$@"
        return
    fi
    
    local command=""
    local kind=""
    local pattern=""
    local skip_direct_execution=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                set -x
                shift
                ;;
            search|describe|get|delete)
                command="$1"
                kind="$2"
                pattern="$3"
                # Shift only the arguments that exist
                if [ $# -ge 3 ]; then
                    shift 3
                elif [ $# -ge 2 ]; then
                    shift 2
                else
                    shift
                fi
                # Remaining args are passed to the command function
                break
                ;;
            logs)
                command="$1"
                kind="pods"
                pattern="$2"
                shift 2
                # Remaining args are passed to the command function
                break
                ;;
            exec)
                command="$1"
                kind="pods"
                skip_direct_execution=true
                shift 1  # Remove command, keep all remaining args for exec function
                # Remaining args are passed to the command function
                break
                ;;
            connect)
                command="$1"
                kind="pods"
                skip_direct_execution=true
                shift 1  # Remove command, keep all remaining args for connect function
                # Remaining args are passed to the command function
                break
                ;;
            *)
                $KUBECTL_CMD $@
                exit 0
                ;;
        esac
    done
    
    # Validate command, kind, and pattern
    if [ -z "$command" ]; then
        echo "Error: Command is required"
        show_help
        exit 1
    fi
    
    if [ -z "$kind" ]; then
        echo "Error: Kind is required"
        show_help
        exit 1
    fi

    # Handle commands like kubectl get pods -A
    if [[ "$skip_direct_execution" == "false" ]] && ([ -z "$pattern" ] || [[ "$pattern" =~ ^- ]]); then
        # If pattern is a flag, add it back to the arguments
        if [[ "$pattern" =~ ^- ]]; then
            set -- "$pattern" "$@"
        fi
        $KUBECTL_CMD "$command" "$kind" "$@"
        exit 0
    fi
    
    # Execute command
    case $command in
        search)
            search "$kind" "$pattern" "$@"
            ;;
        describe)
            kubectl_wrapper_command "describe" "$kind" "$pattern" "$@"
            ;;
        get)
            get_yaml "$kind" "$pattern" "$@"
            ;;
        delete)
            kubectl_wrapper_command "delete" "$kind" "$pattern" "$@"
            ;;
        logs)
            logs "$kind" "$pattern" "$@"
            ;;
        exec)
            exec "$@"
            ;;
        connect)
            connect "$1" "$2"
            ;;
        *)
            echo "Unknown command: $command"
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
