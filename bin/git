#!/bin/bash

set -e

# Check if first argument is one of our custom commands
case "$1" in
  save|delete|d|rebase|rebasem|pushm|owner|owners|dev|clean|commit|retry|help|-h|--help)
    # Parse arguments for custom commands - normalize ACTION to static values
    case "$1" in
      save)           ACTION="save" ;;
      delete|d)       ACTION="delete" ;;
      retry)          ACTION="retry" ;;
      rebase)         
        # Special case: if $2 exists, pass through to git rebase
        if [ -n "$2" ]; then
          ACTION="passthrough"
        else
          ACTION="rebase"
        fi
        ;;
      rebasem)        ACTION="rebasem" ;;
      pushm)          ACTION="pushm" ;;
      owner|owners)   ACTION="owner" ;;
      dev)            ACTION="dev" ;;
      clean)          ACTION="clean" ;;
      commit)
        # Special case: if $2 exists, pass through to git commit
        if [ -n "$2" ]; then
          ACTION="passthrough"
        else
          ACTION="commit"
        fi
        ;;
      help|-h|--help) ACTION="help" ;;
    esac
    
    if [ "$ACTION" != "passthrough" ]; then
      shift
      CUSTOM_ARGS=("$@")
    fi
    ;;
  *)
    # Not a custom command, pass everything to git
    ACTION="passthrough"
    ;;
esac

# Generic function to get original command path (bypassing wrapper scripts)
get_original_command() {
    local cmd="$1"
    if [ -z "$cmd" ]; then
        echo "Error: command name required" >&2
        return 1
    fi
    
    local original_path="$PATH"
    local script_dir=$(dirname "$0")
    PATH=$(echo "$PATH" | sed "s|:$script_dir||g" | sed "s|^$script_dir:||g")
    local cmd_path=$(command -v "$cmd")
    PATH="$original_path"
    echo "$cmd_path"
}

# Get the original git command
GIT_PATH=$(get_original_command "git")

save() {
  current_branch=`git branch --show-current`
  TARGET_BRANCH="$current_branch"
  if [ ! -z "$1" ]; then
    TARGET_BRANCH="$1"
  fi

  if [ "$TARGET_BRANCH" != "$current_branch" ]; then
    $GIT_PATH checkout $TARGET_BRANCH
  fi

  latest_saved_version=`git branch | grep -E "aetmp[0-9]+" | cut -d'p' -f2 | sort -Vr | head -n 1`
  new_branch_name="aetmp$((latest_saved_version + 1))"
  $GIT_PATH checkout -b $new_branch_name
  $GIT_PATH checkout $current_branch
}

delete() {
  local save_branch="$1"
  local target_branch="$2"
  
  if [ -z "$target_branch" ]; then
     target_branch=`$GIT_PATH branch --show-current`
     $GIT_PATH checkout main
  fi
  if [[ "$save_branch" == "true" ]]; then
     save $target_branch
  fi
  $GIT_PATH branch -D $target_branch
}

rebase_self() {
  save
  $GIT_PATH rebase -i HEAD~10
}

pull_branch() {
  TARGET_BRANCH="$1"
  current_branch=`git branch --show-current`
  $GIT_PATH checkout $TARGET_BRANCH
  $GIT_PATH pull
  $GIT_PATH checkout $current_branch
}

dev() {
  TARGET_BRANCH=`git branch --show-current`
  DEV_BRANCH_NAME="dev/ae-$TARGET_BRANCH"
  $GIT_PATH branch -D $DEV_BRANCH_NAME 2>/dev/null
  $GIT_PATH checkout -b $DEV_BRANCH_NAME
  $GIT_PATH push -u origin $DEV_BRANCH_NAME --force
  $GIT_PATH checkout $TARGET_BRANCH
}

print_branch_owners() {
  $GIT_PATH for-each-ref --format='%(refname:short) %(authorname)' refs/remotes/
}

clean() {
  local count="$1"
  
  if [ -z "$count" ] || ! [[ "$count" =~ ^[0-9]+$ ]]; then
    echo "Usage: git clean <number>"
    echo "Deletes the specified number of smallest versioned aetmp branches"
    return 1
  fi
  
  local versions_to_remove=$($GIT_PATH branch | grep -E "aetmp[0-9]+" | cut -d'p' -f2 | sort -V | head -n "$count")
  
  if [ -z "$versions_to_remove" ]; then
    echo "No aetmp branches found"
    return 0
  fi

  echo "$versions_to_remove" | sed 's/^/aetmp/' | while read branch_name; do
    $GIT_PATH branch -D "$branch_name"
  done
}

# Action handler methods
handle_save() {
    save "${CUSTOM_ARGS[0]}"
}

handle_delete() {
    local skip_save=false
    local target_branch=""
    
    # Parse arguments
    for arg in "${CUSTOM_ARGS[@]}"; do
        case $arg in
            -s|--skip|-skip|s)
                skip_save=true
                ;;
            *)
                if [ -z "$target_branch" ]; then
                    target_branch="$arg"
                else
                    echo "Error: Too many arguments. Expected: git delete [-s] <branch_name>"
                    exit 1
                fi
                ;;
        esac
    done
    local save_branch="true"
    if [ "$skip_save" = true ]; then
        save_branch="false"
    fi
    delete "$save_branch" "$target_branch"
}

handle_rebase() {
    # Only override if no additional arguments (preserve original git rebase behavior)
    if [ ${#CUSTOM_ARGS[@]} -eq 0 ]; then
        rebase_self
    else
        $GIT_PATH -c gpg.format=ssh rebase "${CUSTOM_ARGS[@]}"
    fi
}

handle_rebasem() {
    local target_branch="main"
    if ! $GIT_PATH branch | grep -q "$target_branch"; then
        target_branch="main"
    fi
    if [ -n "${CUSTOM_ARGS[0]}" ]; then
        target_branch="${CUSTOM_ARGS[0]}"
    fi
    save
    pull_branch "$target_branch"
    $GIT_PATH rebase "$target_branch"
}

handle_pushm() {
    handle_rebasem    
    local current_branch=$($GIT_PATH branch --show-current)
    $GIT_PATH push -u origin "$current_branch" --force
}

handle_owners() {
    $GIT_PATH remote prune origin
    print_branch_owners
}

handle_commit() {
    $GIT_PATH commit -m "INTERIM WORK"
}

handle_retry() {
    save
    $GIT_PATH commit --amend --no-edit --date=now
}

handle_help() {
    echo "Git wrapper is being used and overriding the git help command."
    echo "Run '$GIT_PATH -h' to show git help"
    echo ""
    echo "Custom Commands:"
    echo "  save [branch]           - Create a versioned backup branch (aetmpN) from current or specified branch"
    echo "  delete [branch]         - Delete a branch (saves backup first unless -s flag is used)"
    echo "  rebase                  - Interactive rebase of last 10 commits (saves backup first)"
    echo "  rebasem [branch]        - Pull and rebase onto main (or specified branch), saves backup first"
    echo "  pushm [branch]          - Calls rebasem then pushes current branch to origin"
    echo "  clean <number>          - Delete the N oldest aetmp backup branches"
    echo "  commit                  - Quick commit with 'INTERIM WORK' message"
    echo "  retry                   - Save backup and amend last commit with current timestamp"
    echo "  dev                     - Create and push dev/ae-<branch> branch, then return to original"
    echo "  owner|owners            - Show branch owners from remote"
    echo ""
    echo "Flags:"
    echo "  -s, --skip              - (for delete) Skip saving backup before deletion"
}

# Action dispatch
case "$ACTION" in
    save)           handle_save ;;
    delete)         handle_delete ;;
    rebase)         handle_rebase ;;
    rebasem)        handle_rebasem ;;
    pushm)          handle_pushm ;;
    owner)          handle_owners ;;
    dev)            dev ;;
    clean)          clean "${CUSTOM_ARGS[0]}" ;;
    commit)         handle_commit ;;
    retry)          handle_retry ;;
    help)           handle_help ;;
    passthrough)    $GIT_PATH -c gpg.format=ssh "$@" ;;
    *)              echo "Error: Unknown action '$ACTION'" >&2; exit 1 ;;
esac

