#!/bin/bash

# Docker Snapshot Script
# Launches a Docker image, shells into it, and creates a snapshot with a new tag

set -e

usage() {
    cat << EOF
Usage: docker_edit [OPTIONS] INPUT_IMAGE OUTPUT_TAG

Launch a Docker image, shell into it, make changes, and create a snapshot.

ARGUMENTS:
    INPUT_IMAGE    The Docker image to launch (e.g., ubuntu:20.04)
    OUTPUT_TAG     The tag for the new snapshot image (e.g., my-modified-ubuntu:latest)

OPTIONS:
    --no-flatten   Don't flatten the image (keeps layer dependencies)
    -h, --help     Show this help message

EXAMPLES:
    docker_edit ubuntu:20.04 my-ubuntu:v1
    docker_edit --no-flatten alpine:latest my-alpine:modified

WORKFLOW:
    1. Script launches the specified Docker image
    2. You get a shell inside the container
    3. Make your changes inside the container
    4. Exit the shell (Ctrl+D or 'exit')
    5. Script creates a snapshot with the specified output tag
    6. By default, creates a flattened independent image
    7. Container is automatically cleaned up

EOF
}

error() {
    echo "[ERROR] $1" >&2
    exit 1
}

# Default settings
FLATTEN=true

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --no-flatten)
            FLATTEN=false
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            error "Unknown option: $1. Use -h for help."
            ;;
        *)
            if [ -z "$INPUT_IMAGE" ]; then
                INPUT_IMAGE="$1"
            elif [ -z "$OUTPUT_TAG" ]; then
                OUTPUT_TAG="$1"
            else
                error "Too many arguments. Use -h for help."
            fi
            shift
            ;;
    esac
done

if [ -z "$INPUT_IMAGE" ] || [ -z "$OUTPUT_TAG" ]; then
    error "Both INPUT_IMAGE and OUTPUT_TAG are required. Use -h for help."
fi

# Extract repository name from input image to build proper output image name
if [[ "$INPUT_IMAGE" == *":"* ]]; then
    REPO_NAME="${INPUT_IMAGE%:*}"
    OUTPUT_IMAGE="${REPO_NAME}:${OUTPUT_TAG}"
else
    OUTPUT_IMAGE="$OUTPUT_TAG"
fi

# Generate unique container name
CONTAINER_NAME="snapshot-$(date +%s)-$$"

# Set up cleanup trap to remove container
cleanup() {
    if [ -n "$CONTAINER_NAME" ]; then
        echo "Cleaning up container: $CONTAINER_NAME"
        docker rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
    fi
}
trap cleanup EXIT

echo "Starting container: $CONTAINER_NAME from image: $INPUT_IMAGE"
echo "Make your changes inside the container, then exit to create snapshot."
echo ""

docker run -it --user root --entrypoint "/bin/sh" --name "$CONTAINER_NAME" "$INPUT_IMAGE"

echo ""
echo "Creating snapshot: $OUTPUT_IMAGE"
docker commit "$CONTAINER_NAME" "$OUTPUT_IMAGE"
echo "Snapshot created successfully: $OUTPUT_IMAGE"

if [ "$FLATTEN" = true ]; then
    echo "Flattening image to make it independent..."
    
    # Get the original image to copy its configuration
    ORIGINAL_IMAGE="$INPUT_IMAGE"
    
    # Create a temporary tarball of the container filesystem
    TEMP_TAR="/tmp/container-${CONTAINER_NAME}.tar"
    echo "Exporting container filesystem..."
    docker export "$CONTAINER_NAME" > "$TEMP_TAR"
    
    # Import the tarball as a base image (no metadata)
    TEMP_BASE_IMAGE="${OUTPUT_IMAGE}-base"
    docker import "$TEMP_TAR" "$TEMP_BASE_IMAGE"
    
    # Now create a new container from the base and copy the original image's config
    echo "Copying original image configuration..."
    TEMP_CONTAINER="${CONTAINER_NAME}-config"
    
    # Get original image config
    ORIGINAL_CMD=$(docker inspect "$ORIGINAL_IMAGE" --format='{{json .Config.Cmd}}')
    ORIGINAL_ENTRYPOINT=$(docker inspect "$ORIGINAL_IMAGE" --format='{{json .Config.Entrypoint}}')
    ORIGINAL_ENV=$(docker inspect "$ORIGINAL_IMAGE" --format='{{.Config.Env}}')
    ORIGINAL_WORKDIR=$(docker inspect "$ORIGINAL_IMAGE" --format='{{.Config.WorkingDir}}')
    ORIGINAL_USER=$(docker inspect "$ORIGINAL_IMAGE" --format='{{.Config.User}}')
    
    echo "Original config found:"
    echo "  CMD: $ORIGINAL_CMD"
    echo "  ENTRYPOINT: $ORIGINAL_ENTRYPOINT"
    echo "  ENV: $ORIGINAL_ENV"
    echo "  WORKDIR: $ORIGINAL_WORKDIR"
    echo "  USER: $ORIGINAL_USER"
    
    # Create final image by committing the base with original config
    docker create --name "$TEMP_CONTAINER" "$TEMP_BASE_IMAGE" /bin/true >/dev/null
    
    # Build commit options to restore original config
    COMMIT_OPTIONS=""
    if [ "$ORIGINAL_CMD" != "null" ] && [ "$ORIGINAL_CMD" != "[]" ]; then
        COMMIT_OPTIONS="$COMMIT_OPTIONS --change='CMD $ORIGINAL_CMD'"
    fi
    if [ "$ORIGINAL_ENTRYPOINT" != "null" ] && [ "$ORIGINAL_ENTRYPOINT" != "[]" ]; then
        # Escape inner quotes in the JSON for proper command construction
        ESCAPED_ENTRYPOINT=$(echo "$ORIGINAL_ENTRYPOINT" | sed 's/"/\\"/g')
        COMMIT_OPTIONS="$COMMIT_OPTIONS --change=\"ENTRYPOINT $ESCAPED_ENTRYPOINT\""
    fi
    if [ -n "$ORIGINAL_WORKDIR" ] && [ "$ORIGINAL_WORKDIR" != "" ]; then
        COMMIT_OPTIONS="$COMMIT_OPTIONS --change='WORKDIR $ORIGINAL_WORKDIR'"
    fi
    if [ -n "$ORIGINAL_USER" ] && [ "$ORIGINAL_USER" != "" ]; then
        COMMIT_OPTIONS="$COMMIT_OPTIONS --change='USER $ORIGINAL_USER'"
    fi
    
    # Apply environment variables
    if [ "$ORIGINAL_ENV" != "[]" ] && [ -n "$ORIGINAL_ENV" ]; then
        # Parse the format: [VAR1=value1 VAR2=value2] and convert to --change options
        ENV_VARS=$(echo "$ORIGINAL_ENV" | sed 's/^\[//' | sed 's/\]$//' | tr ' ' '\n' | while read env; do 
            if [ -n "$env" ]; then 
                echo "--change='ENV $env'"; 
            fi 
        done | tr '\n' ' ')
        COMMIT_OPTIONS="$COMMIT_OPTIONS $ENV_VARS"
    fi
    
    ## echo "Committing with options: $COMMIT_OPTIONS"
    ## echo "EXACT COMMAND THAT WILL BE EXECUTED:"
    ## echo "docker commit $COMMIT_OPTIONS \"$TEMP_CONTAINER\" \"$OUTPUT_IMAGE\""
    ## echo ""
    eval "docker commit $COMMIT_OPTIONS \"$TEMP_CONTAINER\" \"$OUTPUT_IMAGE\""
    
    # Cleanup
    docker rm "$TEMP_CONTAINER" >/dev/null 2>&1 || true
    docker rmi "$TEMP_BASE_IMAGE" >/dev/null 2>&1 || true
    rm -f "$TEMP_TAR"
    
    echo "Image flattened and made independent with original configuration preserved"
fi

# Show the new image
echo ""
echo "New image details:"
docker images | head -1  # header
docker images | grep "$OUTPUT_TAG" | head -1
