#!/bin/bash
# set -x

DOCKER_PATH=""
DOCKER_PUSH_DIR="$HOME/.aedev"
DOCKER_PUSH_LOG="$DOCKER_PUSH_DIR/docker_pushes.txt"

if [ -f "/usr/local/bin/docker" ]; then
  DOCKER_PATH="/usr/local/bin/docker"
fi
if [ -z "$DOCKER_PATH" ]; then
  echo "Could not find docker installation location."
  exit 1
fi

clean() {
  $DOCKER_PATH images  | tr -s ' '  | grep "<none> <none>" | cut -d' ' -f3  | xargs -I {} $DOCKER_PATH rmi {} 
}

clean_all() {

  tmpfile=$(mktemp)
  tmpout=$(mktemp)
  $DOCKER_PATH images --format '{{.Repository}} {{.Tag}}' > "$tmpfile"

  TMPFILE="$tmpfile" TMPOUT="$tmpout" python3 - <<EOF
import sys
from collections import defaultdict
import os

tmpfile = os.environ['TMPFILE']
tmpout = os.environ['TMPOUT']

def parse_version(v):
  return tuple(int(x) for x in v.strip().split('.'))

data = defaultdict(list)

with open(tmpfile) as f:
  for line in f:
    try:
      repo, tag = line.strip().split()
      if not all(part.isdigit() for part in tag.split('.')):
        continue
      data[repo].append(tag)
    except:
      continue

with open("$tmpout", "w") as f:
  for repo, versions in data.items():
    sorted_versions = sorted(versions, key=parse_version)
    latest = sorted_versions[-1]
    outdated = [v for v in sorted_versions if v != latest]
    if len(outdated) > 0:
      print()
      print(f"{repo}")
      print(f"Latest: {latest}")
      for outdate in outdated:
        print(f"  {outdate}")
        f.write(f"{repo}:{outdate}\n")
EOF
  echo ""
  echo "Will Delete"
  cat $tmpout | xargs -n 1
  echo ""
  echo ""
  cat $tmpout | xargs -n 1 | xargs -I {} $DOCKER_PATH rmi {}

}

push() {
  local tag="$2"
  
  local image_id=$($DOCKER_PATH images --format "{{.ID}}" "$tag" | head -n1)
  
  if [ -z "$image_id" ]; then
    echo "Could not find image for tag: $tag"
    return 1
  fi
  
  if [ -f "$DOCKER_PUSH_LOG" ] && grep -q "^$tag,$image_id," "$DOCKER_PUSH_LOG"; then
    echo "Tag $tag with image ID $image_id already pushed, skipping"
    return 0
  fi
  
  $DOCKER_PATH "$@"
  push_succeeds="$?"
  if [ $push_succeeds -eq 0 ]; then
    register_push "$tag" "$image_id"
  else
    echo "Docker push failed"
    return 1
  fi
}

register_push() {
  local tag="$1"
  local image_id="$2"
  
  if [ -z "$tag" ]; then
    echo "No tag provided to register_push"
    return 1
  fi
  
  if [ -z "$image_id" ]; then
    echo "No image ID provided to register_push"
    return 1
  fi
  
  local epoch_time=$(date +%s)  
  mkdir -p $DOCKER_PUSH_DIR
  echo "$tag,$image_id,$epoch_time" >> $DOCKER_PUSH_LOG
  
  if [ -f "$DOCKER_PUSH_LOG" ]; then
    local line_count=$(wc -l < "$DOCKER_PUSH_LOG")
    if [ "$line_count" -gt 300 ]; then
      tail -n +101 "$DOCKER_PUSH_LOG" > "$DOCKER_PUSH_LOG.tmp" && mv "$DOCKER_PUSH_LOG.tmp" "$DOCKER_PUSH_LOG"
    fi
  fi
}

if [[ "$1" == "clean" && "$2" == "all" ]]; then
  set -e
  clean 
  clean_all
  set +e
elif [[ "$1" == "clean" ]]; then
  set -e
  clean
  set +e
elif [[ "$1" == "push" ]]; then
  push "$@"
elif [[ "$1" == "-h" || "$1" == "--help" ]]; then
  echo "docker clean # Cleans all 'none' tags"
  echo "docker clean all # Cleans all 'none' tags and old versions"
  echo "docker push # Pushes a tag and image id, skips pushing if already recently pushed"
else
  $DOCKER_PATH "$@"
fi
