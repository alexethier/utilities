#!/bin/bash
#
# Docker Wrapper Script
#
# Wraps the docker binary to add custom commands to ease docker usage.
#
# set -x

DOCKER_PATH=""
DOCKER_PUSH_DIR="$HOME/.aedev"
DOCKER_PUSH_LOG="$DOCKER_PUSH_DIR/docker_pushes.txt"
DOCKER_PULL_LOG="$DOCKER_PUSH_DIR/docker_pulls.txt"

if [ -f "/usr/local/bin/docker" ]; then
  DOCKER_PATH="/usr/local/bin/docker"
fi
if [ -z "$DOCKER_PATH" ]; then
  echo "Could not find docker installation location."
  exit 1
fi

clean() {
  $DOCKER_PATH images  | tr -s ' '  | grep "<none> <none>" | cut -d' ' -f3  | xargs -I {} $DOCKER_PATH rmi {} 
}

clean_all() {

  tmpfile=$(mktemp)
  tmpout=$(mktemp)
  $DOCKER_PATH images --format '{{.Repository}} {{.Tag}}' > "$tmpfile"

  TMPFILE="$tmpfile" TMPOUT="$tmpout" python3 - <<EOF
import sys
from collections import defaultdict
import os

tmpfile = os.environ['TMPFILE']
tmpout = os.environ['TMPOUT']

def parse_version(v):
  return tuple(int(x) for x in v.strip().split('.'))

data = defaultdict(list)

with open(tmpfile) as f:
  for line in f:
    try:
      repo, tag = line.strip().split()
      if not all(part.isdigit() for part in tag.split('.')):
        continue
      data[repo].append(tag)
    except:
      continue

with open("$tmpout", "w") as f:
  for repo, versions in data.items():
    sorted_versions = sorted(versions, key=parse_version)
    latest = sorted_versions[-1]
    outdated = [v for v in sorted_versions if v != latest]
    if len(outdated) > 0:
      print()
      print(f"{repo}")
      print(f"Latest: {latest}")
      for outdate in outdated:
        print(f"  {outdate}")
        f.write(f"{repo}:{outdate}\n")
EOF
  echo ""
  echo "Will Delete"
  cat $tmpout | xargs -n 1
  echo ""
  echo ""
  cat $tmpout | xargs -n 1 | xargs -I {} $DOCKER_PATH rmi {}

}

push() {
  local image_reference="$2"
  
  local image_id=$($DOCKER_PATH images --format "{{.ID}}" "$image_reference" | head -n1)
  
  if [ -z "$image_id" ]; then
    echo "Could not find image for: $image_reference"
    return 1
  fi
  
  if [ -f "$DOCKER_PUSH_LOG" ] && grep -q "^$image_reference,$image_id," "$DOCKER_PUSH_LOG"; then
    echo "Image $image_reference with image ID $image_id already pushed, skipping"
    return 0
  fi
  
  $DOCKER_PATH "$@"
  push_succeeds="$?"
  if [ $push_succeeds -eq 0 ]; then
    register_push "$image_reference" "$image_id"
  else
    echo "Docker push failed"
    return 1
  fi
}

register_push() {
  local image_reference="$1"
  local image_id="$2"
  
  local epoch_time=$(date +%s)  
  mkdir -p $DOCKER_PUSH_DIR
  echo "$image_reference,$image_id,$epoch_time" >> $DOCKER_PUSH_LOG
  
  if [ -f "$DOCKER_PUSH_LOG" ]; then
    local line_count=$(wc -l < "$DOCKER_PUSH_LOG")
    if [ "$line_count" -gt 300 ]; then
      tail -n +101 "$DOCKER_PUSH_LOG" > "$DOCKER_PUSH_LOG.tmp" && mv "$DOCKER_PUSH_LOG.tmp" "$DOCKER_PUSH_LOG"
    fi
  fi
}

pull() {
  local image_reference="$2"
  local tag="${image_reference##*:}"
 
  # Check the pull log to check if eligible for skipping
  if [ -f "$DOCKER_PULL_LOG" ] && grep -q "^$image_reference," "$DOCKER_PULL_LOG"; then
    # Verify the image exists in the local repo
    local image_id=$($DOCKER_PATH images --format "{{.ID}}" "$image_reference" | head -n1)
    if [ -n "$image_id" ]; then
      echo "Image $image_reference with image ID $image_id already pulled, skipping"
      return 0
    else
      echo "Image $image_reference was previously pulled but no longer exists locally, cleaning log entry"
      grep -v "^$image_reference," "$DOCKER_PULL_LOG" > "$DOCKER_PULL_LOG.tmp" && mv "$DOCKER_PULL_LOG.tmp" "$DOCKER_PULL_LOG"
    fi
  fi

  $DOCKER_PATH "$@"
  local pull_succeeds="$?"
  
  if [ $pull_succeeds -eq 0 ]; then
    # Only register pulls on eligible images (released and versioned images)
    if [[ -n "$tag" ]] && [[ ! "$image_reference" =~ SNAPSHOT$ ]] && [[ "$tag" != "$image_reference" ]] && [[ "$tag" != "latest" ]]; then
      local image_id=$($DOCKER_PATH images --format "{{.ID}}" "$image_reference" | head -n1)
      if [ -n "$image_id" ]; then
        register_pull "$image_reference"
      fi
    fi
  else
    return 1
  fi
}

register_pull() {
  local image_reference="$1"
  
  local epoch_time=$(date +%s)  
  mkdir -p $DOCKER_PUSH_DIR
  echo "$image_reference,$epoch_time" >> $DOCKER_PULL_LOG
  
  if [ -f "$DOCKER_PULL_LOG" ]; then
    local line_count=$(wc -l < "$DOCKER_PULL_LOG")
    if [ "$line_count" -gt 300 ]; then
      tail -n +101 "$DOCKER_PULL_LOG" > "$DOCKER_PULL_LOG.tmp" && mv "$DOCKER_PULL_LOG.tmp" "$DOCKER_PULL_LOG"
    fi
  fi
}

find_matching_image_ids() {
  local search_string="$1"
  local all_images="$2"
  
  # Find all matching image IDs
  # Match on: exact ID, exact full repository name, or if repository ends with search string
  echo "$all_images" | awk -v search="$search_string" '
    {
      id = $1
      repo = $2
      
      # Check if ID matches exactly
      if (tolower(id) == tolower(search)) {
        print id
        next
      }
      
      # Check if full repository name matches exactly
      if (tolower(repo) == tolower(search)) {
        print id
        next
      }
      
      # Check if repository ends with the search string (basename matching)
      # This handles cases like:
      # - "openflow-ingress-controller" matches "*/openflow-ingress-controller"
      # - "ingress-nginx/controller" matches "*/ingress-nginx/controller"
      search_lower = tolower(search)
      repo_lower = tolower(repo)
      
      # If search contains /, match the suffix after any registry domain
      # Otherwise, match just the last component after the last /
      if (index(search, "/") > 0) {
        # Search has /, so match if repo ends with it
        if (substr(repo_lower, length(repo_lower) - length(search_lower) + 1) == search_lower) {
          # Also check that it is preceded by / or is the full string
          if (length(repo_lower) == length(search_lower) || substr(repo_lower, length(repo_lower) - length(search_lower), 1) == "/") {
            print id
          }
        }
      } else {
        # Search has no /, extract basename (last component after /)
        n = split(repo, parts, "/")
        basename = parts[n]
        if (tolower(basename) == search_lower) {
          print id
        }
      }
    }
  ' | sort -u
}

list() {
  local search_string="$1"
  local max_name_length=120
  
  # Get images with custom format (no size)
  local images_output=$($DOCKER_PATH images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedSince}}")
  
  # Filter by search string if provided (preserve header)
  if [ -n "$search_string" ]; then
    images_output=$(echo "$images_output" | awk -v search="$search_string" '
      NR == 1 { print; next }
      tolower($0) ~ tolower(search) { print }
    ')
  fi
  
  # Process and format the output - two pass: first to find max width, second to print
  echo "$images_output" | awk -v max_len="$max_name_length" '
    NR == 1 {
      # Skip header on first pass
      header_line = $0
      next
    }
    {
      repo = $1
      tag = $2
      id = $3
      created = ""
      for (i = 4; i <= NF; i++) {
        created = created (i > 4 ? " " : "") $i
      }
      
      # Truncate repository name from the middle if too long
      if (length(repo) > max_len) {
        keep_start = int(max_len * 0.4)
        keep_end = int(max_len * 0.4)
        ellipsis = "..."
        repo = substr(repo, 1, keep_start) ellipsis substr(repo, length(repo) - keep_end + 1)
      }
      
      # Store data and track max repo width
      repos[NR] = repo
      tags[NR] = tag
      ids[NR] = id
      createds[NR] = created
      
      if (length(repo) > max_repo_width) {
        max_repo_width = length(repo)
      }
    }
    END {
      # Ensure minimum width for header
      if (max_repo_width < 10) max_repo_width = 10
      
      # Print header
      printf "%-*s  %-20s  %-12s  %s\n", max_repo_width, "REPOSITORY", "TAG", "IMAGE ID", "CREATED"
      
      # Print all rows
      for (i = 2; i <= NR; i++) {
        printf "%-*s  %-20s  %-12s  %s\n", max_repo_width, repos[i], tags[i], ids[i], createds[i]
      }
    }
  '
}

remove() {
  local search_string="$1"
  
  if [ -z "$search_string" ]; then
    echo "Usage: docker remove <search_string>"
    echo "Searches for images by name or ID and removes all matching images"
    return 1
  fi
  
  # Get all images with their ID, Repository, and Tag
  local all_images=$($DOCKER_PATH images --format '{{.ID}} {{.Repository}} {{.Tag}}')
  
  # Find all matching image IDs using the new matching function
  local matching_ids=$(find_matching_image_ids "$search_string" "$all_images")
  
  if [ -z "$matching_ids" ]; then
    echo "No images found matching: $search_string"
    return 1
  fi
  
  echo "Found matching image IDs:"
  echo "$matching_ids"
  echo ""
  
  # Collect all removal specs for each matching ID
  local images_to_remove=$(for image_id in $matching_ids; do
    echo "$all_images" | grep "^$image_id " | while read id repo tag; do
      if [ "$repo" != "<none>" ] && [ "$tag" != "<none>" ]; then
        # Both repo and tag are valid - remove by repo:tag
        echo "TAG:$repo:$tag"
      else
        # Either repo or tag is <none>, or both - must remove by ID
        # (removing by repo name alone defaults to :latest which won't work for <none> tags)
        echo "ID:$id"
      fi
    done
  done)
  
  if [ -z "$images_to_remove" ]; then
    echo "No images to remove"
    return 0
  fi
  
  echo "Images to be removed:"
  echo "$images_to_remove" | sed 's/^TAG:/  /; s/^ID:/  (by ID) /'
  echo ""
  
  # Wait for user confirmation
  read -p "Proceed with removal? (y): " confirmation
  if [[ -n "$confirmation" && ! "$confirmation" =~ ^([yY]|[yY][eE][sS])$ ]]; then
    echo "Removal cancelled"
    return 0
  fi
  echo ""
  
  # Remove all images
  echo "$images_to_remove" | while read removal_spec; do
    if [ -n "$removal_spec" ]; then
      local target="${removal_spec#*:}"
      $DOCKER_PATH rmi "$target"
    fi
  done
  
  echo ""
  echo "Removal complete"
}

if [[ "$1" == "clean" && "$2" == "all" ]]; then
  set -e
  clean 
  clean_all
  set +e
elif [[ "$1" == "clean" ]]; then
  set -e
  clean
  set +e
elif [[ "$1" == "push" ]]; then
  push "$@"
elif [[ "$1" == "pull" ]]; then
  pull "$@"
elif [[ "$1" == "list" ]]; then
  list "$2"
elif [[ "$1" == "remove" || "$1" == "delete" ]]; then
  remove "$2"
elif [[ "$1" == "-h" || "$1" == "--help" ]]; then
  echo "Docker Wrapper - Custom commands for docker"
  echo "Using docker binary: $DOCKER_PATH"
  echo ""
  echo "Custom Commands:"
  echo "  clean                      - Remove all untagged images (<none>:<none>)"
  echo "  clean all                  - Remove untagged images and old versioned images"
  echo "  push <tag>                 - Push image, skip if already pushed (tracked in ~/.aedev/docker_pushes.txt)"
  echo "  pull <tag>                 - Pull image and register the pull (tracked in ~/.aedev/docker_pulls.txt)"
  echo "  list [string]              - List images, optionally filtered by grep pattern"
  echo "  remove|delete <string>     - Remove images matching name or ID"
  echo "                               Matches by: exact ID, full repo name, or basename"
  echo "                               Examples: 'ingress-nginx/controller'"
  echo ""
  echo "All other commands are passed through to: $DOCKER_PATH"
  echo ""
  echo "Usage: docker [command] [options]"
else
  $DOCKER_PATH "$@"
fi
