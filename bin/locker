#!/usr/bin/env python3

import os
import argparse

LOCK_SUFFIX = ".lock"
SAVE_SUFFIX = ".bytes"
SAVE_LENGTH = 1000
HEX_PATTERN = "0000FFFF0000FFFF"

class DirectoryManager:
    DATA_DIR = os.path.expanduser("~/.aedev")
    DATA_FILE = os.path.join(DATA_DIR, "locker.data")
    
    def __init__(self):
        self.directories = []
    
    def validate_directory(self, dir_path):
        abs_path = os.path.abspath(dir_path)
        
        if not os.path.exists(abs_path):
            raise ValueError(f"Directory does not exist: {abs_path}")
        
        if not os.path.isdir(abs_path):
            raise ValueError(f"Path is not a directory: {abs_path}")
        
        path_parts = abs_path.split(os.sep)
        if len(path_parts) <= 3:
            raise ValueError(f"Directory path too shallow (must be > 2 levels deep): {abs_path}")
        
        return abs_path
    
    def add_directories(self, dir_list):
        for dir_path in dir_list:
            validated_path = self.validate_directory(dir_path)
            self.directories.append(validated_path)
    
    def get_directories(self):
        self.save_to_file()
        return self.directories
    
    def save_to_file(self):
        if not os.path.exists(self.DATA_DIR):
            os.makedirs(self.DATA_DIR)
        
        with open(self.DATA_FILE, 'w') as f:
            for directory in self.directories:
                abs_path = os.path.abspath(directory)
                f.write(abs_path + '\n')
    
    def load_from_file(self):
        if os.path.exists(self.DATA_FILE):
            with open(self.DATA_FILE, 'r') as f:
                return [line.strip() for line in f.readlines() if line.strip()]
        return []

class FileLocker:
    def __init__(self):
        pass

    def generate_byte_sequence(self, path):
        byte_lock_pattern = bytearray.fromhex(HEX_PATTERN)
        num_bytes = len(byte_lock_pattern)
        output_bytes = bytearray(num_bytes)

        with open(path, 'rb') as f_in:
            file_bytes = f_in.read(num_bytes)
            for i in range(num_bytes):
                output_bytes[i] = file_bytes[i] ^ byte_lock_pattern[i]
        return output_bytes

    def save_bytes(self, path, length=SAVE_LENGTH):
        save_path = path + SAVE_SUFFIX
        if not os.path.exists(save_path) or os.path.getsize(save_path) == 0:
            file_bytes = None
            with open(path, 'rb') as f_in:
                file_bytes = f_in.read(length)

            with open(save_path, 'w+b') as f_out:
                print(f"Saving file to {save_path}")
                f_out.write(file_bytes)

    def apply_lock(self, path, lock_bytes):
        with open(path, 'r+b') as f_out:
            f_out.write(lock_bytes)
        lock_path = path + LOCK_SUFFIX
        os.rename(path, lock_path)

    def apply_unlock(self, path, lock_bytes):
        with open(path, 'r+b') as f_out:
            f_out.write(lock_bytes)
        unlock_path = path[:-len(LOCK_SUFFIX)]
        os.rename(path, unlock_path)

    def lock_file(self, path):
        self.save_bytes(path)
        lock_bytes = self.generate_byte_sequence(path)
        self.apply_lock(path, lock_bytes)

    def unlock_file(self, path):
        unlock_bytes = self.generate_byte_sequence(path)
        self.apply_unlock(path, unlock_bytes)

    def restore_file(self, path):

        restore_path = path + SAVE_SUFFIX
        restore_bytes = None
        with open(restore_path, 'rb') as f_in:
            restore_bytes = f_in.read(SAVE_LENGTH)

        with open(path, 'r+b') as f_out:
            f_out.write(restore_bytes)

    def lock_directory(self, dir_path):
        print(f"Locking directory {dir_path}")
        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            if os.path.isfile(item_path) and not (item_path.endswith("bytes") or item_path.endswith("lock")):
                print(f"Locking file {item_path}")
                self.lock_file(item_path)

        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            if os.path.isdir(item_path):
                self.lock_directory(item_path)

    def unlock_directory(self, dir_path):
        print(f"Unlocking directory {dir_path}")
        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            if os.path.isfile(item_path) and item_path.endswith("lock"):
                print(f"Unocking file {item_path}")
                self.unlock_file(item_path)

        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            if os.path.isdir(item_path):
                self.unlock_directory(item_path)

    def restore_directory(self, dir_path):
        print(f"Restoring directory {dir_path}")
        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            restore_path = item_path + SAVE_SUFFIX
            if os.path.isfile(item_path) and os.path.isfile(restore_path):
                print(f"Restoring file {item_path}")
                self.restore_file(item_path)

        for item in os.listdir(dir_path):
            item_path = os.path.join(dir_path, item)
            if os.path.isdir(item_path):
                self.restore_directory(item_path)

    def main(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-l', '--lock', action='store_true', default=False, help='lock files')
        parser.add_argument('-u', '--unlock', action='store_true', default=False, help='unlock files')
        parser.add_argument('-r', '--restore', action='store_true', default=False, help='restore files')
        parser.add_argument('-d', '--directories', nargs='+', help='directories to process (default: current directory)')
        args = vars(parser.parse_args())
        
        if args["lock"] and args["unlock"]:
            raise Exception("Lock and unlock cannot both be set.")
        if not (args["lock"] or args["unlock"] or args["restore"]):
            raise Exception("One of lock, unlock, or restore must be set.")

        directories = args["directories"] if args["directories"] else [os.getcwd()]
        
        dir_manager = DirectoryManager()
        dir_manager.add_directories(directories)

        for directory in dir_manager.get_directories():
            if args["lock"]:
                self.lock_directory(directory)
            if args["unlock"]:
                self.unlock_directory(directory)
            if args["restore"]:
                self.restore_directory(directory)

file_locker = FileLocker()
file_locker.main()
