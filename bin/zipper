#!/bin/bash

# Zipper - intelligent zip file manager with open/close workflow
# Maintains state to recreate zip files from extracted directories

set -eu -o pipefail
IFS=$'\n\t'

usage() {
    cat << EOF
Usage: zipper [OPTIONS]

Intelligent zip file manager that tracks extracted files for easy re-zipping.

OPTIONS:
    -o, --open FILE        Open/extract a zip file to working directory
    -c, --close            Close/recreate zip from previously extracted directory
    -z, --skip-backup      Skip creating backup of original zip file
    -v, --verbose          Verbose mode (set -x)
    -h, --help             Show this help message

EXAMPLES:
    zipper -o archive.zip                 # Extract archive.zip to aetmp_archive.zip/
    zipper --close                        # Recreate zip from current directory
    zipper -o file.zip --skip-backup      # Extract without backup

WORKFLOW:
    OPEN:  1. Creates working directory (aetmp_<filename>)
           2. Copies zip file to working directory
           3. Extracts contents
           4. Saves metadata for later recreation

    CLOSE: 1. Finds UNZIP_PROPERTIES.txt in directory hierarchy
           2. Recreates zip file with same name
           3. Optionally backs up original
           4. Cleans up working directory

EOF
}

PROPERTIES_FILE="UNZIP_PROPERTIES.txt"
UNZIP_PREFIX="aetmp"
OPEN_FILEPATH=""
CLOSE_DIR="false"
SKIP_BACKUP="false"

# Parse command line
while [[ $# > 0 ]]
do
    key="$1"
    set +u
    value="$2"
    set -u

    case $key in
        -o|--open)
            OPEN_FILEPATH="$value"
            shift
            ;;
        -c|--close)
            CLOSE_DIR="true"
            ;;
        -z|--skip-backup)
            SKIP_BACKUP="true"
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -v|--verbose)
            set -x
            ;;
        *)
            echo "Unknown option passed: $key"
            echo "Use -h or --help for usage information."
            exit 1
            ;;
    esac
    shift
done

if [ -n "${OPEN_FILEPATH}" ]; then
    if [ ! -f "${OPEN_FILEPATH}" ]; then
        echo "'$OPEN_FILEPATH' is not a valid file."
        exit 1
    fi

    parent_dir=`dirname ${OPEN_FILEPATH}`
    filename=`basename ${OPEN_FILEPATH}`
    workdir="$parent_dir/${UNZIP_PREFIX}_${filename}"
    if [ -d "$workdir" ]; then
        echo "'Work directory '$workdir' already exists."
    fi

    mkdir $workdir
    cp ${OPEN_FILEPATH} $workdir
    echo "filename=$filename" >> "$workdir/$PROPERTIES_FILE"
    cd $workdir && unzip $filename
fi

if [ "$CLOSE_DIR" == "true" ]; then
    while true; do
        if [ -f "./$PROPERTIES_FILE" ]; then
            break
        else
            current_cwd=`pwd`
            parent_path=`dirname $current_cwd`
            if [ "$parent_path" == "$current_cwd" ]; then
                echo "Cannot find any $PROPERTIES_FILE in directory hierarchy"
                exit 1
            fi
            cd $parent_path
        fi
    done
    
    orig_filename=`cat "./$PROPERTIES_FILE" | grep filename | cut -d'=' -f2-`
    zipped_dirname=`pwd | xargs basename`
    echo "Found zip properties at $zipped_dirname"
    if [ -f "../$orig_filename" ] && [ "${SKIP_BACKUP}" == "false" ]; then
        mv "../$orig_filename" "../backup.$orig_filename"
    fi

    rm -f $PROPERTIES_FILE
    rm -f $orig_filename
    echo "Creating $orig_filename by zipping *"
    zip -r ../$orig_filename *

    if [[ "$zipped_dirname" == "$UNZIP_PREFIX"* ]]; then
        cd ..
        parent_path=`pwd`
        rm -rf $zipped_dirname
        echo ""
        echo "Run the following to get back to the dir: cd $parent_path"
    fi
fi
